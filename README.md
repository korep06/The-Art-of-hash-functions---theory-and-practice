# Искусство хеш-функций - теория и практика
**Цель урока:** Понять, что идеальная хеш-функция (без коллизий) часто невозможна, изучить принципы создания хороших хеш-функций (равномерность, скорость, устойчивость) и научиться комбинировать хеши полей сложных структур.

---

#### 1. Ключевые термины и определения

- **Совершенная хеш-функция:** Функция, которая гарантированно возвращает разные хеши для разных входных данных. На практике достижима только для очень ограниченного набора ключей.
    
- **Коллизия:** Неизбежная ситуация для большинства хеш-функций, когда два разных входных данных дают одинаковый хеш.
    
- **Криптографическая стойкость:** Свойство хеш-функции, делающее computationally infeasible (вычислительно неосуществимым) нахождение коллизий или восстановление исходных данных по хешу. Примеры: SHA-256, BLAKE3.
    
- **Соль (Salt):** Случайные или псевдослучайные данные, которые добавляются к исходным данным перед хешированием для усложнения поиска коллизий через атаки по словарю.
    
- **Комбинирование хешей:** Техника создания хеша для сложного объекта путем комбинации хешей его полей с использованием операций (умножение на простое число, сложение, XOR).
    

---

#### 2. Основные концепции и теории

- **Теоретическая ограниченность:** Количество возможных хешей (значений типа `size_t`) всегда конечно, в то время как количество возможных входных данных (например, строк или структур) бесконечно или чрезвычайно велико. Поэтому коллизии в принципе неизбежны.
    
- **Цель хорошей хеш-функции:** Не исключить коллизии (это невозможно), а минимизировать их вероятность и сделать их непредсказуемыми.
    
- **Три ключевых свойства хорошей хеш-функции:**
    
    1. **Детерминированность:** Один и тот же вход всегда дает один и тот же хеш.
        
    2. **Равномерность:** Хеши должны равномерно распределяться по всему диапазону возможных значений.
        
    3. **Скорость:** Вычисление должно быть быстрым.
        
- **Метод умножения на простое число:** Распространенный и эффективный способ комбинирования хешей. Простое число (например, 37 или 31) помогает лучше "перемешивать" биты и избегать закономерностей, которые могут привести к кластеризации коллизий.
    

---

#### 3. Синтаксис и код

**Наивная (плохая) хеш-функция для структуры:**


```cpp
struct Fragment {
    uint64_t begin;
    uint64_t end;
};

struct FragmentHasherNaive {
    size_t operator() (const Fragment& f) const {
        return static_cast<size_t>(f.begin + f.end); // Легко найти коллизии
    }
};
```

**Улучшенная хеш-функция (комбинирование с простым числом):**


```cpp
struct FragmentHasher {
    size_t operator() (const Fragment& f) const {
        const size_t prime = 37;
        return static_cast<size_t>(f.begin * prime + f.end);
    }
};
```
// Лучше, но все еще уязвима для целенаправленного подбора коллизий.

**Хеш-функция для структуры с тремя полями:**



```cpp
struct Circle {
    double x;
    double y;
    double r;
};

struct CircleHasher {
    size_t operator() (const Circle& circle) const {
        std::hash<double> d_hasher;
        const size_t prime = 37;

        size_t h_x = d_hasher(circle.x);
        size_t h_y = d_hasher(circle.y);
        size_t h_r = d_hasher(circle.r);

        // Комбинируем хеши полей, умножая на степени простого числа
        return h_x + h_y * prime + h_r * (prime * prime);
    }
};
```

**Хеш-функция для вектора (переменное количество полей):**

cpp

```cpp
struct IntVectorHasher {
    size_t operator() (const std::vector<int>& vec) const {
        size_t seed = 0;
        const size_t prime = 37;
        for (int num : vec) {
            // Комбинируем хеш текущего элемента с аккумулятором
            seed = seed * prime + static_cast<size_t>(num);
        }
        return seed;
    }
};
```

_Пояснение к коду: Этот подход позволяет создать хеш для контейнера, количество элементов в котором неизвестно заранее. Каждый новый элемент "добавляется" к общему хешу путем умножения аккумулятора на простое число и прибавления значения элемента._

---

#### 4. Важные заметки и подводные камни

- **Коллизии неизбежны.** Не стремитесь создать идеальную функцию. Стремитесь создать функцию, которая сводит вероятность коллизий к приемлемому минимуму для вашей задачи.
    
- **Используйте разные степени для разных полей.** Если для двух разных полей использовать одинаковый множитель, их вклад в итоговый хеш может "скомпенсировать" друг друга, ухудшив равномерность.
    
- **Не используйте криптографические хеши без необходимости.** Такие функции как SHA-256 очень медленные. Они предназначены для защиты данных, а не для использования в `unordered_map`. Их использование убивает производительность.
    
- **Проверяйте свои хеш-функции.** Напишите тесты, которые проверяют, что равные объекты имеют равные хеши, и что хеши разных объектов распределяются равномерно.
    
- **Избегайте паттернов.** Простая функция `f.begin + f.end` создает много коллизий для объектов с одинаковой суммой (например, фрагменты одинаковой длины). Умножение на простое число помогает разнести такие паттерны.
    
- **Помните о требованиях `unordered_map`:** Если `a == b`, то `hash(a) == hash(b)`. Обратное неверно — именно это и есть коллизия.

### Пример

```cpp
#include <iostream>
#include <string>
#include <unordered_set>
#include <unordered_map>

using namespace std;

// Функция для поиска коллизий хеш-функции в тексте
// Хешер передается как параметр шаблона. Текст читается из потока по словам.
// Коллизией считается ситуация, когда новое слово имеет тот же хеш, что и предыдущее слово,
// но при этом отличается от всех слов с этим хешом.
template <typename Hash>
int FindCollisions(const Hash& hasher, istream& text) {
    string word;
    int collisions_count = 0;
    
    // Структура для хранения данных:
    // ключ - хеш слова, значение - множество уникальных слов с этим хешом
    unordered_map<size_t, unordered_set<string>> hash_to_words;

    while (text >> word) {
        size_t hash_value = hasher(word);
        
        // Если хеш уже встречался
        if (hash_to_words.count(hash_value)) {
            // Если слово с таким хешом уже есть в множестве - это не коллизия
            if (hash_to_words[hash_value].count(word)) {
                continue;
            }
            else {
                // Новое слово с существующим хешом - коллизия!
                ++collisions_count;
                hash_to_words[hash_value].insert(word);
            }
        }
        else {
            // Новый хеш - добавляем слово в множество
            hash_to_words[hash_value].insert(word);
        }
    }
    
    return collisions_count;
}

// Простой (и плохой) хешер для тестирования
// Недостаток: производит только сумму кодов символов,
// что приводит к частым коллизиям (например, "ab" и "ba" дают одинаковый хеш)
struct HasherDummy {
    size_t operator()(const string& str) const {
        size_t res = 0;
        for (char c : str) {
            res += static_cast<size_t>(c);
        }
        return res;
    }
};

int main() {
    // Используем стандартную хеш-функцию для строк
    hash<string> str_hasher;
    
    int collisions = FindCollisions(str_hasher, cin);
    cout << "Found collisions: "s << collisions << endl;
}
```
